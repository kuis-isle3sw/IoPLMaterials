{% include head.html %}

# (F)AQ

## OCaml に関する質問

### OCamlFormat

> 「また,作業ディレクトリに.ocamlformatファイルを(空でもよいので)用意するとインデント等が自動的に整理されてよい.」(https://kuis-isle3sw.github.io/IoPLMaterials/textbook/setting-up-ocaml.html)　「作業ディレクトリ」はホームディレクトリということでしょうか。

想定としては「cloneしてきたソースコードの入っているディレクトリ」で大丈夫だと思います（多分）

### `::` について

> 本テスト・クイズの問題4で使われている2重コロンはどういう意味なのでしょうか。

> 演算子 :: の意味は知らなかったので、五十嵐先生の Objective Caml 入門を読み直して復習しようと思います。インタプリタとコンパイラが「一行ずつ解釈」／「全体を翻訳」、という相対する概念であるという考え方を修正することが出来たのが今回最大の学びでした。

`::`はリストを作るときに使うコンストラクタです．
```ocaml=
# 1 :: [];;
- : int list = [1]
# 1 :: 2 :: 3 :: [];;
- : int list = [1; 2; 3]
# 1 :: [2; 3; 4];;
- : int list = [1; 2; 3; 4]
```
から大体の動きを想像してもらうとありがたいです．

### OCaml における破壊的代入

> 書き換え可能なデータ構造およびそれを再帰ヴァリアントに追加した場合の動作については習わなかったので、勉強用の資料があると嬉しいです。

例えば，[https://kuis-isle3sw.github.io/IoPLMaterials/textbook/mltext.pdf](これ)の6章と7章あたりはどうでしょう．

### OCaml における結合とその強さ

> "関数定義式よりも関数適用式の方が結合が強いように書いたが合っているのか？AppExprの定義においてe1(左側の項)にAExprを、e2(右側の項)にAppExprを割り当てると右側を再帰的に読み取っていって右結合になるというのは割と目から鱗だった。他の箇所にも応用できそう。"

OCaml では `fun f -> f 1` は

```=
# fun f -> f 1;;
- : (int -> 'a) -> 'a = <fun>
```

のような出力がかえってきます．ここから `(fun f -> f) 1` ではなく `fun f -> (f 1)` のように構文解析されていることがわかります．これにしたがって，関数適用式のほうが結合が強いようになっています．

### 参照型

> "ref型がすごい便利。いつも前の演習問題をして何時間もかけてわかりにくいコードで解けたと思ったら、あとから使えそうなコーディングが授業で使われる。損した気分になります。

一応 OCaml 演習で ref 型も解説してませんでしたっけ？それはそうと，ref 型をできるだけ使わずにプログラミングした方が関数型っぽいのと，デバッグが容易なコードになりがちだと思うのですが，どうですかね．

### 言語処理系のバージョンアップについて

> "授業資料などで、MiniML2→MiniML3→...のようにバージョンが上がっていくような感じがします。実際にOCaml初めその他のプログラミング言語にも「バージョン」という概念がありますが、例えばバージョンアップの時などは今私たちが課題でやったように、言語処理系の中身がいじられて機能が追加される...と言ったことが多いのでしょうか？"

はい，処理系のバージョンが上がると，それに付随していろいろな feature が追加されることはよくあります．たとえば，OCaml 5 ではマルチコア対応や，エフェクトハンドラと呼ばれる例外処理のお化けのような feature が追加されています．

### なぜ `rec`?

> "再帰関数の実装について、説明を読む限りは大まかなイメージができたと思ったのですが、実際にOCamlで実装するとなるとややこしいと思いました。OCamlと違ってC#やHaskellなどは再帰関数を定義するときにrecで区別することがないので実装が少し違うのか気になりました。"

`rec` で区別する理由は，OCaml で以下のようなイディオムを使うことが多いためです．
```ocaml=
let rec fact n res = if n = 0 then res else fact (n-1) (n*res) in
let fact n = fact n 1 in
fact 5
```
1行目で定義している`fact`は末尾再帰版の階乗関数です．2行目の右辺の`fact`は一行目で定義された`fact`を指しています．これはシャドウイングによって，`fact`を再定義しているわけです．もし`let`と`let rec`の区別がなく，全部再帰的定義とする場合，こういうイディオムを使うのは難しくなります．

### OCaml における配列

> "OCaml でランダムアクセスをしたい場合は array を使う (https://ocaml.org/docs/data-structures-comparison) ようなのですが、再帰的な処理を多く行う場合はあまり用いられないのでしょうか？また、OCaml で nth を定義するときに線形時間かかっていたので驚いたのですが、nth を使う機会は頻繁にあったりするのでしょうか？"

リストについてはn番目の要素を参照する際にnに比例した時間がかかります．ただ，リストは再帰的に定義されたデータ型なので，再帰関数で処理を行いやすいという利点があります．どの要素にもO(1)でアクセスできる必要がある場合には配列を使う必要がありますが，こちらは再帰で書くと少し不格好になります．というわけで，用途によって使い分けることになるなあという感じがします．

### OCaml における比較演算子

> "SW3の実験でこの授業で学んだ束縛やクロージャの話を元にOcamlを改めて学ぶのが思いの外楽しいです。本授業におけるMinimlでは不等号の両辺はint型でなければエラーが出ますが、OCaml(および他の言語でも？)では文字列同士でも評価できると知って驚きました。TAさんには評価方法は辞書順に行なっていると伺いましたが、ASCIIコードを参照して評価しているのでしょうか？少し気になりました。"

比較演算子は，適用される型によって異なる実装による比較が行われます．OCaml のプログラムではこのようなことはできないのですが，比較演算子については実装を C プログラムで書くことでこれを可能にしています．（C と OCaml を組み合わせる方法は[ここ](https://v2.ocaml.org/manual/intfc.html)を読んでみてください．）[ライブラリの説明](https://v2.ocaml.org/api/Stdlib.html)では

```
Structural ordering functions. These functions coincide with the usual orderings over integers, characters, strings, byte sequences and floating-point numbers, and extend them to a total ordering over all types. The ordering is compatible with ( = ). As in the case of ( = ), mutable structures are compared by contents. Comparison between functional values raises Invalid_argument. Comparison between cyclic structures may not terminate. Left-associative operator, see Ocaml_operators for more information.
```

のように，どのように比較されるかが明示化されていませんが，実装では辞書式順序になっているようです．

### OCaml の文法

> "講義に直接関係があるわけではない質問になってしまいますが...。
> OCaml 公式 Web サイトのこのあたり：
> https://v2.ocaml.org/releases/5.0/htmlman/language.html
> で言語の BNF が書かれていたりしますが、この BNF で記述されているルールについて、並列に記されているルールは下にあるものほど優先される、あるいは上にあるものほど優先される、というような決まりはあるのでしょうか？
> というのも、例えば
> print_int +5
> という式は、
> https://v2.ocaml.org/releases/5.0/htmlman/expr.html
> に記されている expr の生成規則のうち
> expr ::= expr {argument}*
> でも
> expr ::= expr infix-op expr
> でも、どちらの規則でも当てはまりそうで、じゃあ別に追加のルールがないとどちらの規則に当てはめてパースするか決められないなあ、と思ったので気になった次第です。
> ちなみに実際に動かしてみたところ、この例で出した式は後者でパースされるようでした。"

これ，いろいろ考えてみたのですが，よくわかりませんでした．そもそもなんで `+` が prefix symbol として扱えるんだろう．．．


## 概論的な部分についての質問

### インタプリタとコンパイラの違い

> 	インタプリタとコンパイラの本質的な違いは、インタプリタは自身が構文解析をして、状態に応じて異なる結果を返すもので、コンパイラの役割は単に高水準言語をアセンブリに変換するものという認識であっていますか？

どちらかというと，インタプリタはプログラムの実行結果を出力として返すもの，コンパイラはプログラムと等価なプログラムを出力として返すもの，という理解の方が正しいです．例えば，OCamlインタプリタは
```ocaml=
# let x = 3 in x + 2;;
- : int = 5
```
のように，`let x = 3 in x + 2`の実行結果である`5`を出力として返していますが，
```bash=
# tmp.ml の内容を表示するコマンド
> cat tmp.ml
let x = 3 in x + 2;;
# ocamlopt は OCaml ファイルを実行可能ファイルに変換するコンパイラ
> ocamlopt -O3 -o tmp tmp.ml
# file はファイルの種類を表示するコマンド． tmp が arm64 の実行可能ファイルであることがわかる．
> file tmp
tmp: Mach-O 64-bit executable arm64
```
のように OCaml コンパイラは OCaml プログラムを実行可能形式の別のプログラムに変換しています．

### 原初のプログラミング言語について

> MiniMLとは，Ocamlで書かれたOcamlのインタプリタである，という認識で正しいでしょうか．なんとなく面白いです．インタプリタなら，同じくらい高級な言語で書けるのは理解しました．一方でコンパイラは低級な言語で記述されるもので，辿っていくといつかアセンブリ言語や機械語にたどり着くのでしょうか．

MiniML は OCaml で書かれた OCaml のサブセットのインタプリタという理解で正しいです．後段ですが，多分言語 $L_n$ のコンパイラを実装するために言語 $L_{n-1}$ を使い，言語 $L_{n-1}$ のコンパイラを実装するために言語 $L_{n-2}$ を使い．．．と続けていくと，最初のコンパイラはどうなっているのか，という質問かなと理解しました．

実は僕はあまり詳しくないのですが，詳しくないなりに説明すると，別の言語を極力使わずに言語 L の処理系を作るための bootstrapping と呼ばれる手法があります．この手法では，L の小さいサブセット L0 の処理系を別の言語 K で定義しておき，この L0 で少し大きいサブセット L1 のための処理系を記述して L1 の処理系を得て，L1 で記述された少し大きいサブセット L2 のための処理系を記述して，L2 の処理系を得る．．．というようにだんだん大きい言語を定義することで L の処理系を得ます．この方法であれば，最初の L0 の処理系を作るために K を使う部分だけ別の言語を使うことになり，それ以外の部分はすべて L のサブセットで定義することができます．一般的にはこの K への依存すらなくすのは難しいんだと思います．（多分本当に原初の K まで遡ると，アセンブリやバイナリを人間が頑張って手で書いていたあたりに遡るのかなと想像します．）

### バイトコードとネイティブコード

> 講義内で、インタプリタはプログラムの計算を実行し、コンパイラは等価な別のプログラムを返すという違いがあるという説明がありました。あるプログラムについて、インタプリタに与えて実行したときの、そのプログラムに依存する機械語と、コンパイラによって変換された機械語では、かなり違いが生じるのでしょうか。

> OCaml がコンパイラによる処理とインタプリタによる処理の両方をサポートしているということは今まで知らなかったことで、驚いた。両者で何らかの挙動の違いはあるのか、また、なぜコンパイラとインタプリタの両方をサポートしているのかと疑問に思った。

OCaml のコンパイラには，OCaml プログラムをバイトコードに変換する `ocamlc` と，ネイティブコード（実行可能バイナリ）に変換する `ocamlopt` があります．`ocamlc`によって生成されるバイトコードは，`ocamlrun`というバイトコード用のインタプリタで実行することができるのですが，そうであればバイトコード生成と`ocamlrun`を組み合わせれば OCaml プログラム用のインタプリタが作れてしまうので，このように実装されています．

`ocamlopt`と`ocamlc`+`ocamlrun`は，一応挙動の違いは内容に設計されているはずです．ただ，tupleの要素の評価順序など，意味論が未定義な部分の挙動が異なるアーキテクチャもあった気がします．例えば，
```bash=
# tmp.ml の内容を表示する
> cat tmp.ml
(Printf.printf "a\n", Printf.printf "b\n", Printf.printf "c\n")
# tmp というバイトコードを生成
> ocamlc -o tmp tmp.ml
# tmp.bin という実行可能バイナリを生成
> ocamlopt -o tmp.bin tmp.ml
# 両方とも表示順序は同じ．
> ./tmp
c
b
a
> ./tmp.bin
c
b
a
```
上記の `tmp` と `tmp.bin` で文字列の表示順序が異なる場合が昔はありました．今はどうか分からん．

## インタプリタについて

### 遅延評価と if 式

> また、一つ質問なのですが、課題1のExercise 3.9について、OCamlでは評価戦略がcall by valueであるためにif式を関数で書けないと考えたのですが、では評価戦略がcall by needであるHaskellでは関数でif式を書くことができるのでしょうか？お答えいただけると幸いです。"

可能です．こんなかんじ．

```haskell=
ghci> myif b e1 e2 = if b then e1 else e2
ghci> fact n = myif (n==0) 1 (n*(fact (n-1)))
ghci> (fact 0, fact 5)
(1,120)
```

### menhir について

> Menhirについて質問です。構文解析器が与えられたトークン列を生成するための規則を順番に解析していき、最終的に規則列が判明した後に還元時アクションを実行して開始記号の属性を計算する、とありますが、開始記号の属性の計算は何のために行こなうのでしょうか。

開始記号の属性が，構文解析器がプログラム側に返す値となります．なので，開始記号の属性としてプログラム全体の AST を返してやる必要があります．

### Python における環境

> Pythonなど他言語のインタプリタを実行する際にも変数の宣言や代入が行われるときは内部的には環境という形で変数の束縛情報の保持/更新がなされているのだろうか？"

「環境」という名前で呼ばれているかはわからないですが，変数の型情報や値の情報は管理してると思います．（でないと，変数の値を参照することができない！）

### なぜプログラミング言語の構文定義に文脈自由文法が使われるか

> プログラミング言語のシンタックスを定義するにあたって、文脈自由文法以外(文脈依存など)を用いるとまずい具体的な理由を知りたいです。

まずいわけではないのですが，文脈自由文法（のあるサブクラス）の構文解析アルゴリズムの性能がめっちゃいいというのが理由としてあるんじゃないかなと思います．あと，AST が直感的なのもあるのかもしれません．（文脈の情報を木でエンコードするのは結構大変そう．）

### `parser.mly` について

#### 構文の定義について

> "Parser.mlyの文法規則の記述の部分の質問です。構文解析器はトークン列から抽象構文木に変換するものだと認識しているのですが、その場合規則の最初はトークン列のTRUE SEMISEMIが来ると思ったのですが、なぜ_Expr_ SEMISEMIから開始しているのでしょうか"

`TRUE SEMISEMI` だと，`true;;` というプログラムしか構文解析できなくなってしまいます．`Expr SEMISEMI` にしていれば，非終端記号 `Expr` から導出されるものが `SEMISEMI` の前に来れます．`parser.mly` の定義を丁寧に追うと，`Expr` から `TRUE` が導出できるのがわかると思います．

#### Parser や Lexer の内部動作の確認方法

> - ex3_2_2 の実装にあたって：実際生成された Parser や Lexer の signature や内部の論理はどこかで確認できますか？VS Code の拡張機能を利用すれば signature が確認できるのですが、実際手作業で確認したい場合どうすればよいのでしょうか。

一応 `parser.ml` や `lexer.ml` が実装になっていますが，これはなかなか読みにくいと思います．以下のようにするともう少し読みやすいような記述が生成できるかもしれません．

1. `dune-project` ファイルの `(lang dune 1.6)` を `(lang dune 3.0)` に，`(using menhir 2.0)` を `(using menhir 2.1)` に置き換える．
2. `dune` ファイルの
```
(env
 (dev
  (flags
   (:standard -warn-error -A -w -39)
)))
```
を
```
(env
 (dev
  (menhir_flags --dump --explain)
  (flags
   (:standard -warn-error -A -w -39)
)))
```
に変更
3. `dune runtest` を実行．
4. `_build/default/src/parser.automaton` をエディタで開く．

（うまく行かなったら Slack で知らせてください．）

#### 曖昧性について

> Parser.mlyを拡張していくにつれて、文法が曖昧性をもたないことに自信がなくなってきました。リテラルと中置演算子だけで構成されているトークン列に関しては現在のやり方でうまく優先順位が付けられていることが証明できましたが、let式やif式、fun式などが追加されていくと不安になります。

文法が曖昧であるときには， `shift/reduce conflict` とか， `reudce/reduce conflict` とかいう警告が出ます．これを読み飛ばさないことが肝要です．

### MiniML インタプリタのモジュール構成について

> "- モジュール周りに対する理解が浅いのですが、例えば Eval や Parser などといったモジュールがあること（つまりそれらのモジュールの signature？）はどこで定義されているのですか？プログラムで `open Eval` や `Eval.Error` などの記述が可能になっているのでどこかに定義されていると思うのですが、見つかりませんでした...

モジュール `Eval` の実装は `eval.ml` に，インターフェイスは `eval.mli` に記述されています．ファイル名の拡張子を除いた部分の最初の文字を大文字にしたものがモジュール名になる，という規則になっています．

### テストにおける `undef` について

> - ex3_2_3 の実装にあたって：undef はどのように定義されていたのでしょうか？テストが通るように `b1 && undef = b1, b1 || undef = true, undef && undef = undef || undef = undef` という評価にしたのですが、実際はどういう想定でしょうか？"

`undef` は評価した瞬間にエラーになるように評価してほしいです．そのためには，`false && undef` は `undef` を評価することなく `false` を返し，`ture || undef` は `undef` を評価することなく `true` を返さなければならりません．OCaml でも実際にそのように実装されているはず．

### 関数閉包とプロトタイプ宣言

> 関数閉包の話は他のプログラミング言語におけるプロトタイプ宣言の実装にも必要となってくるのでしょうか？

プロトタイプ宣言ではあまり必要ではなくて，むしろ実行時に関数を表す値をどのように表現するかに関わってきます．プロトタイプ宣言はむしろ関数の型を宣言する方法に近いかと．

### 再帰関数の実装方法

> 静的束縛関する質問です。関数を表す値に環境を入れるという方法を取るのではなく、関数を定義したときにその定義式に現れる自由変数を評価し、即値として関数に入れておく、という考え方はよくないのでしょうか。例えば問題 2 で例として使ったコードにおいて:
> ```
> let f =
>     let x = 2 in
>     fun y -> x
> in f false;;
> ```
> 関数 f は (id, body, env) = (""f"", FunExp(""y"", Var ""x""), [(""x"", 2), ......]) というように表されていると思うのですが、定義の時点で関数の本体式 y -> x を、束縛変数 y を除いた部分だけ評価してしまって y -> 2 として、(id, body) = (""f"", FunExp(""y"", ILit 2)) と保存してしまっても問題ないかと思っております。

はい，これはよい気づきで，再帰関数の扱いを工夫すればMiniMLくらいであればうまくいくかもしれないのですが，一般にはうまくいきません．挙げてもらった例では `x` の束縛先が `3` というすでに値になっている式なので置き換えてしまう方法で上手くいくのですが，

```
let x = print_string "hoge" in
let f () = (x, x) in
  f ()
```

のようなプログラムを考えて見てください．このプログラムを OCaml に入力すると，`hoge` という文字列が一回だけ実行されますが，`f`中の`x`を単純に置き換えると

```
let f () = (print_string "hoge", print_string "hoge") in
```

となってしまい，これを呼ぶと `hoge` が2回出力されてしまいます．これでは意味が変わってしまっていますね．

また，関数閉包中に同じ変数が何度も現れており，その変数の束縛先が巨大な値だったりすると，値を全部コピーする必要があって，メモリ効率的に問題があります．

### 関数閉包に含むべき変数

> 環境のキャプチャはクロージャ本体に現れる自由変数だけで良い思った。現実では環境のコピーにどれくらいオーバーヘッドが発生するか気になりました。

はい，クロージャ本体に現れる自由変数のみでよいです．現実のオーバーヘッドは計測してみないとわかりませんが，スコープ内の変数の数がクロージャ内の自由変数よりも圧倒的に多い場合には，クロージャ内の自由変数だけをコピーする方が効率的でしょう．

### `exval` と `dnval`

> eval.mlで定義されているdnvalという型はなんの目的で用意されたものですか？

これについては，[教科書](https://kuis-isle3sw.github.io/IoPLMaterials/textbook/chap03-2.html)を見てもらうとよいかなと思います．講義中にも少し言及したので，必要であればそちらも．（どの回だったっけ...）

### 関数閉包を使わなくてもよい関数

> 関数作成時にクロージャを作るのはまあまあオーバーヘッドがかかる処理なのかなと思ったので、実用的なプログラミング言語において環境をクロージャに含めなくても実行できる関数はクロージャが必要な関数と区別されているのかなと気になりました。

少なくともコンパイラではクロージャを作らなくてよい場合（すなわち，クロージャを作らず，関数定義が書かれているラベルにジャンプするだけで良い場合）はクロージャを作らないように最適化されている場合が多いかなと思います．ミニなコンパイラですが，[住井先生のMinCamlコンパイラ](https://esumii.github.io/min-caml/)もそのように実装されていた記憶があります．

### `^[[C` とは

> minimlの標準入力で左ボタンおしたら下記のような文字が入力されます。これはなんなんでしょうか。
```
# ^[[C"
```

ターミナルが左ボタンに対応付けられたコードを表示する際の特殊な文字です．[この stackoverflow](https://stackoverflow.com/questions/21384040/why-does-the-terminal-show-a-b-c-d-when-pressing-the-arrow-k)の記事がよくまとまっています．このコードを受け取ったときにカーソルを実際に左に動かす機能がインタプリタに実装されていないため，このような文字が表示されます． `rlwrap dune exec miniml` とかで起動すると左キーでちゃんとカーソルが左に動くかもしれない．

### `LetRecExp` の型について

> "Exercise 3.5.1 の実装ですが、LetRecExp などを `id * id * exp * exp` と定義するのではなく、`id * exp * exp` と定義し、真ん中の exp が FunExp であることを parser 側で要請する、という実装をしてみました。少し手間ではありましたが、こうしたほうがきれいかと考えました。あえて `id * id * exp * exp` としている理由を、もしあれば教えてください。自分で実装にあたって一つ気付いたのは、eval.ml の実装で現在の環境に (id, dummyenv) を拡張する際に、結局 `ProcV (para, exp1, dummyenv)` を書かざるを得なくて (真ん中の exp を eval_exp のパターンマッチに任せる、という実装が無理)、FunExp の良さを活かせないという点でした。"

これはありうるのですが，真ん中の `exp` が関数であることを `exp` 型のレベルで強制したいという理由で現在の実装になっています．Parser で強制するのは手なのですが，`exp`型の値が（手で直接書くこともできるので） parser で生成されたもののみとは限らないという問題があります．関数であることを強制しない場合は，`let rec f = f in f` のような式をいちいち排除する必要があり，ちょっと面倒です．（OCaml はご提案頂いた方式で実装されていると思うのですが，実際に再帰的定義の右側に何が来てよいかのチェックは，結構面倒です．今回は実装をシンプルにするために関数であることを型のレベルで強制しています．）

### `ProcV` の pretty printing

> "元々出ていたWarningを解消するためにpretty printingを拡張したのだが、ProcVを表すために新たにstring_of_expが必要になり、以下のような定義をしたのだが問題はないだろうか。Slackで投げるとネタバレになりかねないなと思いここで投げたが、今後pretty printingの記法が指定されることがあった時にこの辺りが原因でエラーが出ると悲しいので先に伺っておきたい。

（コードのレイアウトがちょっと面倒だったので削りました．）

多分大丈夫だと思います．が，OCamlではクロージャを出力するときに，単に`<fun>`と表示されます．
```ocaml=
# let x = fun n -> n + 1;;
val x : int -> int = <fun>
#
```
必ずしもコードの文字列表現が手に入るわけではないためこのようになっているんだと思います．多分．

### meta-circular interpreter

> "少し前回内容になってしまうのですが、質問です。再帰の定義式導入のためにrecなどをsyntaxやparserに加えましたが、それらを加える前からevalにはlet rec宣言がなされていました。どうしてこのようなことが可能なのでしょうか？"

eval.ml は，現在我々が実装しているインタプリタを実現するための OCaml のプログラムです．OCaml にはすでに let rec 等のプリミティブがあるため，eval.mlはこれを用いて記述されています．したがって，我々のインタプリタが let rec を解釈できなくても，OCaml はeval.mlを解釈することができます．

それでは，我々のインタプリタの機能ををどんどん拡張して，例えば `type` を用いたユーザ型定義や `match` を用いた型推論等まで実装して，我々のインタプリタを我々のインタプリタ自身で解釈できるようになるでしょうか．答えは YES で，これができると，我々のインタプリタを OCaml で作り，我々のインタプリタに我々のインタプリタを読み込ませる，みたいなことができます．このようなことができるに至ったインタプリタを meta-circular interpreter と言ったりします．

## 型について

### 型推論

> 型推論という概念についてですが、「推論」という概念だけにどうしても機械学習のイメージと結びついてしまうのですが、正しいですか？

機械学習における推論は，学習されたモデルを（一般には未知の）データに適用してタスクを行うことを言うので，型推論でいうような推論とはちょっと違うかもしれませんね．個人的には型推論もプログラム中の変数の使われ方を学習しながら型を学習しているといえなくもないので，広い意味では機械学習とか人工知能とか言っても良いと思っています．

### Python の型ヒント

> "Pythonの型ヒントを用いて型の確認を行うmypyなどのツールでは検出が困難なエラーにはどのようなものがありますか？

例えばテンソルの形の不一致などは検出が困難ですね．これについて，最近の国際会議でこんな研究が発表されました．興味があれば読んでみてください．

Momoko Hattori, Naoki Kobayashi, Ryosuke Sato:
Gradual Tensor Shape Checking. ESOP 2023: 197-224
https://link.springer.com/chapter/10.1007/978-3-031-30044-8_8

### 動的型付け言語に後付で型ヒントを追加する難しさ

> (実行時は無視されるとはいえ)型ヒントを充実させれば、他の言語と同じ水準で静的検査ができるのではないかと思っているのですが,動的型付け言語に後付けで型の確認を取り入れるのは困難なものなのでしょうか？"

一般に後付けで型を入れるのは結構たいへんと言われています．今日ちょっと話をした[Types and Programming Language](https://m.kulib.kyoto-u.ac.jp/webopac/EB05985904)の第一章でも以下のように書いてあります．

> Retrofitting a type system onto a language not designed with typechecking in mind can be tricky; ideally, language design should go hand-in-hand with type system design.
> One reason for this is that languages without type systems—even safe, dynamically checked languages—tend to offer features or encourage programming idioms that make typechecking difficult or infeasible. Indeed, in typed languages the type system itself is often taken as the foundation of the design and the organizing principle in light of which every other aspect of the design is considered.
> Another factor is that the concrete syntax of typed languages tends to be more complicated than that of untyped languages, since type annotations must be taken into account. It is easier to do a good job of designing a clean and comprehensible syntax when all the issues can be addressed together. 
> The assertion that types should be an integral part of a programming language is separate from the question of where the programmer must physically write down type annotations and where they can instead be inferred by the compiler. A well-designed statically typed language will never require huge amounts of type information to be explicitly and tediously maintained by the programmer. There is some disagreement, though, about how much explicit type information is too much. The designers of languages in the ML family have worked hard to keep annotations to a bare minimum, using type inference methods to recover the necessary information. Languages in the C family, including Java, have chosen a somewhat more verbose style.

すごく雑にまとめると

- 静的型検査のない言語では，型検査を通らないようなイディオムをみんな使いがち（なので，後付けでそれらを禁止するのは互換性を保つという前提では大変．）
- 静的型検査のある言語ではどうしても annotation が必要になることがあるため，構文が複雑になる傾向がある．

といったところでしょうか．やや古い本ですが，確かに今でもそうだなあと思います．

### Soundness と Completeness

> "Soundnessが重視されているとのことですが、Completenessについてはプログラミング言語の世界ではどのような扱いなのでしょうか？

授業中にも触れた決定可能性にも関わってくるのですが，型エラーが起こらないことを complete に保証する（有限の導出木のみを許す）型システムはある程度プログラミング言語の表現力が高くなると作れません．したがって，complete な型システムを作るという方向性にはあまり人々の興味が向かない傾向があるように思います．

一方で，型システムに対して complete な型推論アルゴリズムは作れる場合があります．すなわち (1) 常に停止して， (2) 与えられたプログラムに型が付くならば型推論アルゴリズムが正しい型を報告し，型がつかないならば型推論アルゴリズムがエラーを報告するようなアルゴリズムは作れる場合があります．（授業で扱う型推論アルゴリズムは，MiniML4 と，その多相型での拡張については，この意味で complete です．）したがって，型推論アルゴリズムと型システムとの関係においては，completeness は重要な性質になります．

（というわけで，何の何に対する soundness/completeness なのかって大事ですね．）

また，completeness がない場合でも，relative completeness と呼ばれる性質が成り立つことはあります．これは雑に言えば，ある決定不能な問題を正しく決定するオラクルがあればcomplete になる，という性質です．例えば命令形言語のための検証システムを与えるホーア論理と呼ばれる論理体系は，整数上の算術を含む一階述語論理式の妥当性判定が決定できるならば完全です．このような妥当性判定は決定不能であることが知られているので，実際には完全ではないのですが，相対完全性の概念を用いることで，何の問題が決定不能であることが completeness を成り立たなくしているかを正しく述べることができます．

### 決定不能な型システム

> 決定不能な型システムで実用的なものは何かありますか？ 

授業中で触れた篩型 (refinement types) を用いた型システムは，refinement に用いる述語の表現力がある程度高い場合に決定不能です．しかしながら，[LiquidHaskell](https://ucsd-progsys.github.io/liquidhaskell/)のように実用的な処理系が存在します．

実際のところ，ある問題 P が決定不能とは，「任意の P のインスタンスを正しく判定し，なおかつ任意のインスタンスについて有限時間で停止する」ような手続きが存在しないことです．したがって，(1) 「任意の P のインスタンス」という条件を諦めて，任意のインスタンスではなくある性質を満たすインスタンスしか扱えないことにする，(2) 「正しく判定」という条件を諦めて，一部のインスタンスについては正しくない結果を返すことを許容する，(3) 「有限時間で停止する」という条件を諦めて，一部のインスタンスについて停止しないことを許容する，というような諦め方をすることで，実用的な手続きを作ることは可能なわけです．

### 実行時型エラーが怒らないことを意味論で定義するには

> 実行時型エラーが起こらないことを意味論的に定義するにはどのようにすればよいのでしょうか？"

プログラミング言語の意味論において，「実行時型エラーが起こる」のはどのような場合かを形式的に定義し，そのような場合に到達可能なプログラムを「実行時型エラーが起こり得る」プログラムと定義するうことで，実行時型エラーが起こらないことを厳密に定義できます．「実行前の型検査を通ったプログラムについては，実行時型エラーが起こらない」という性質（型安全性; type safety, soundness）を証明すれば，型システムの正しさが言えるわけです．

### 型推論の計算量

> 型検査の導出規則はアルゴリズムを実装することを見据えて設計されると思うが、表現力を向上させようとした結果、型検査が多項式時間で解けなくなることがあるのではないかと思った。

上記の LiquidHaskell のように，そもそも決定可能にならないようなものもあるので，多項式時間で解けなくなるケースもザラにあります．授業で扱う型推論は，うまい実装を行えば，プログラムサイズに対してほぼ線形時間で決定することが可能です．（「ほぼ」がミソなのですが．）

### Union 型

> "型判断に構文木が使われているという学びを得た。typescriptのようにユニオン型を導入すればT-ifを保守的にする必要はないという認識で良いのでしょうか"

ユニオン型は有効な拡張ですが，実際にはそれでも結構問題になる場合があります．授業で扱ったような `if true then 1 else false` みたいな例であれば，`int ∨ bool` みたいな型をつけられそうですが，なにか適当な関数 `f` を用いて `(if f 1 then 1 else false) + (if f 1 then 1 else false)` みたいな例を考えると，1つ目の `f 1` と2つ目の `f 1` が同じ結果を返すならば型エラーになりませんが，そうでなければ型エラーが起きてしまいます．これを検証するのは（参照等を用いているせいで `f` が同じ引数に対して異なる結果を返しうる場合には）かなり難しいです．単純な union type では，これは困難なんじゃないかなあ．

### 「最も一般的な型」（主要型）の存在

> 質問ですが、型推論では「最も一般的な型」を推論するのが目標だと思いますが、この「最も一般的な型」が存在する証明というのはどこかで読めますか？例えば let id x = x は 'a → 'a がであり int → int でもあり 'a → 'b ではないが、'a → 'a という最も一般的な型が存在する証明を知りたいです。"

「最も一般的な型」を主要型 (principal type) と呼びます．正確には，以下の条件が満たされるときに型 $\tau$ を princpal type と呼びます: (1) $\Gamma \vdash e : \tau$ かつ， (2) $\Gamma \vdash e : \tau'$ を満たす任意の型 $\tau'$ について，$\theta\tau = \tau'$ を満たす型代入 $\theta$ が存在する．

今回紹介している型推論アルゴリズムは principal type を推論するのですが，それには (1) この型システムで型が付くならば princpal type が存在すること，(2) 型推論アルゴリズムが princpal type を推論すること，の2つを証明する必要があります．このあたりの詳細な議論は，以前紹介した [Types and programming languages](https://m.kulib.kyoto-u.ac.jp/webopac/EB05985904)の22章にあります．（和訳がよければ[型システム入門](https://m.kulib.kyoto-u.ac.jp/webopac/EB07914363)をどうぞ．）大学内からであれば電子ブックを無料でダウンロードできるので読んでみてください．

### C++ における `auto`

> (C++など)手続き型プログラミング言語では、letの型注釈のみ省略できて、関数の引数やリターンの型は省略できないことが多い ですが、どうしてか気になりました。

すみません，最近の C++ をあまり知らなくて（`auto`も最近まで知らなかったくらい）ちょっとこの辺りの事情はよくわかりません．いろいろ調べてみたところ，C++14では返り値の型に auto を使うことも一応できるっぽいですかね．ただ，一般に関数の引数や返り値の型は関数のドキュメントとしても役立つので，（型推論を持つ関数型言語であっても）省略せずに書くのが良い習慣だったりします．

### C# におけるエスケープ解析

> 最近、C#の機能として参照型の参照先が存在することを保証するというのが存在するのを知ったのですが、以下のような複雑な条件式についても、出所が存在しない参照型はコンパイルエラーになるようです。
>
```
private static ref int Error(ref int x, int n)
        {
            ref int r1 = ref x;
            int localInt = 1;
            ref int r2 = ref localInt;
            // r2 がローカル変数から出たものなのでコンパイルエラーになる
            return ref n >= 5 ? r1 : r2;
        }
```
> この実装にも型推論と同様の仕組みが働いているように思うので、かなり便利なアルゴリズムなのだと感じました。"

おお，これは面白いですね．これはいわゆるエスケープ解析というやつで，関数内で定義された値が関数定義の外に出ていきうるかというのを解析する手法です．型を用いたエスケープ解析としては[こんな論文](https://www.cambridge.org/core/journals/journal-of-functional-programming/article/typebased-escape-analysis-for-functional-languages/04423A17BA9A127ADE9BDD149ABF79B2)があります．

### 型システムと抽象解釈

> eval_exp と ty_exp の実装が似ているのは、eval_exp は式を読み解いていった時の最終的な値を評価し、ty_exp は式の型を読み解いていった時の最終的な型を評価するからなのでしょうか？

概ねそう考えてもよいと思います．実際には，型は値を抽象化したものになっています．例えばintは0,1,2,3,...という整数を全部intという一つの型につぶして抽象化しています．boolはtrueとfalseをboolという一つの型につぶして抽象化しています．この型という，いわば抽象化された値で評価を行っているのが型検査と見ることができなくもありません．このように抽象的な値の上での実行と，抽象化されていない元の値でのプログラムの実行との関係を研究する[抽象解釈 (abstract interpretation)](https://en.wikipedia.org/wiki/Abstract_interpretation)という分野があり，プログラム検証に応用されています．

### 型代入について

> [(alpha, TyVar beta); (beta, TyVar alpha)]のような純粋な型に導かない型代入の場合に、どうやって「終わり」がわかりますか？一つの型代入は一回だけやるものですか？

これは前回の講義の型代入のところをもう一度復習してください．この型代入は $\alpha$ を $\beta$ に変換して**から**$\beta$を$\alpha$に変換するという型代入を表します．したがって，$\alpha$は$\alpha$に，$\beta$は$\alpha$に，それ以外の型変数は変化しない，という型代入になっています．

### 型安全でもエラーが起こる例

> 型安全でもエラーが起こる例にどんなものがあるのか気になった

例えば，データの serialization はそのような典型的な例です．Serialization とは，プログラムで用いられる値をディスクに永続的に保存したり他の箇所に送信したりするために予め定めたバイナリ形式に変換することで，例えば Python の pickle などが挙げられます．[OCaml にも serialization がある](https://v2.ocaml.org/releases/4.13/api/Marshal.html)のですが，このserializationの結果は型情報を持たないbytesという値になります．したがって，意図しない型として読み込んでしまうとエラーになることがあります．

### なぜ型スキームの形は限定されているのか

> for all を全体の型の外につけなくてはならない理由がよくわからなかった

$(\forall \alpha. \rightarrow \alpha) \rightarrow (\forall \alpha. \rightarrow \alpha)$ というような型を認めてしまうと型検査と型推論が両方決定不能になってしまうからです．[この論文](https://www.sciencedirect.com/science/article/pii/S0168007298000475)がその証明の初出で，今検索したら[より簡易な証明](https://drops.dagstuhl.de/opus/volltexte/2019/11406/pdf/LIPIcs-TYPES-2018-2.pdf)も発表されているようです．

### `(fun f -> (f 1, f true)) (fun x -> x)`

> (fun f -> (f 1, f true)) (fun x -> x) について，「f が fun x -> x に束縛される」のが実はよくわかっていません．関数適用の引数である fun x -> x が fun f -> (f 1, f true) に適用されるが， fun x -> x は環境を変化させないので，fun f -> (f 1, f true) は空の環境で評価される，というように考えてしまいます．詳しく教えていただけませんか．

とりあえず順を追って評価がどう起こるかを説明してみます．

- `(fun f -> (f 1, f true)) (fun x -> x)` をトップレベルで評価すると，`(fun f -> (f 1, f true))`を評価することによってクロージャが生成されます．
    - このクロージャ中には空の型環境が保持されます．
- `f`の`(fun x -> x)`の評価結果への束縛で，この（空の）型環境を拡張した上で，`(f 1, f true)`が評価されます．
- したがって，`(f 1, f true)`の評価中には`f`は恒等関数に束縛されており，結果として`(1,true)`が返ってくるというわけです．

### OCaml の REPL から MiniML の各モジュールにアクセスする方法

> minimlのプロジェクト内でOCamlのreplからminimlの各モジュールにアクセスする、あるいはそれができるようにreplを起動するには、どうすればよいのでしょうか

> dune build時に対話式実行の時のように各関数の型を知る方法がないのがとても不便。

1. まず．`utop`　という高機能な OCaml の REPL を `opam install utop`でインストールします．
2. プロジェクトのトップレベルのディレクトリで`dune utop`を実行します．すると，MiniML のモジュールがロードされた状態で `utop` の REPL が実行されます．
3. `open Miniml`と入力します．
4. これ以降，MiniMLの各モジュールにアクセスできます．

```
➜  isle3sw--2021-interpreter-ksuenaga git:(master) ✗ dune utop
────────┬─────────────────────────────────────────────────────────────┬─────────
        │ Welcome to utop version 2.6.0 (using OCaml version 4.10.0)! │         
        └─────────────────────────────────────────────────────────────┘         
Findlib has been successfully loaded. Additional directives:
  #require "package";;      to load a package
  #list;;                   to list the available packages
  #camlp4o;;                to load camlp4 (standard syntax)
  #camlp4r;;                to load camlp4 (revised syntax)
  #predicates "p,q,...";;   to set these predicates
  Topfind.reset();;         to force that packages will be reloaded
  #thread;;                 to enable threads


Type #utop_help for help about using utop.

─( 22:18:27 )─< command 0 >──────────────────────────────────────{ counter: 0 }─
utop # open Miniml;;
─( 22:18:27 )─< command 1 >──────────────────────────────────────{ counter: 0 }─
utop # Environment.extend;;
- : string -> 'a -> 'a Environment.t -> 'a Environment.t = <fun>
─( 22:18:31 )─< command 2 >──────────────────────────────────────{ counter: 0 }─
utop # 
➜  isle3sw--2021-interpreter-ksuenaga git:(master) ✗ 
```

### オブジェクト指向言語における型推論

> C++やTypescriptのclassや、RustのTraitなどのOOPのオブジェクトの型検査がどのように行われているのか気になりました。subtyping有りの言語でも使えるようにHM型推論を拡張することはできますか?

> オブジェクト指向の言語では、クラス継承という概念があるせいで型推論がより難しいのかなとおもったので気になりました。"

はい，可能です．[Perplexityが説明をしてくれた](https://www.perplexity.ai/search/2f1f22c0-6390-4e9d-99ea-f938690c6b4e?s=u)ので，これを参考にしてみるとよいかも．

### `fresh_tyvar`

> "Syntax.fresh_tyvarの中の一行、
> let counter = ref 0 in (* 次に返すべき tyvar 型の値を参照で持っておいて， *)
> がよくわかりません。確かにこうすれば変更可能な整数を持つことができますが、それがtyvar型になるのはなぜでしょうか。"

```ocaml=
let fresh_tyvar =
  let counter = ref 0 in (* 次に返すべき tyvar 型の値を参照で持っておいて， *)
  let body () =
    let v = !counter in
      counter := v + 1; v (* 呼び出されたら参照をインクリメントして，古い counter の参照先の値を返す *)
  in body
```

`fresh_tyvar ()` を評価すると，内部関数の `body` が呼び出されます．`body` は古いカウンタの値に `let v = !counter in`で`v`という名前をつけておいて，`counter := v + 1`でカウンタの値をインクリメントしたうえで，`v`を返します．

型を見ると`counter`は`tyvar ref`なのですが，`v`の型は`tyvar`になっており，これが返されるので，全体としては`tyvar`の値が返されるわけです．

### 制約に基づく型推論のメリット

> 等式制約、単一化のメリットがいまいちピンと来ていないのですが、どういったメリット、もしくは役割なのでしょう？

制約を生成して，それを解消する，という形で型推論を行うことで，[MiniML3の型推論](https://kuis-isle3sw.github.io/IoPLMaterials/textbook/chap03-5.html)で出てきた，「今から推論して知るべき型を，型推論器への入力として渡さなければならない問題」を解決することができます．この辺の話は以前の講義で話したと思うので，講義録画も参照してもらえるとよいです．

### 単一化が決定不能であるようなプログラミング言語

> 単一化が決定不能であるようなプログラミング言語で実際に使われているものはありますか？"

単一化に限るとちょっとよくわからないですが，型推論が決定不能であるにも関わらず使われているものとしては，[Coq](https://coq.inria.fr/)や[LiquidHaskell](https://ucsd-progsys.github.io/liquidhaskell/)や[Helmholtz](https://www.fos.kuis.kyoto-u.ac.jp/projects/Helmholtz/)などがあります．

### System F のメリット

> "多相型がつく条件を厳しくすることで健全性を確保しているという点が面白かった。システムFが決定不能とのことですが、型が決定不能な代わりに莫大なメリットがあったりするのでしうか？型が決定不能だと型検査の段階で停止しないケースがありそうで怖いと思ってしまいます。

どの程度説得的な例かはわからないですが，こんな例を作ることはできます．

```ocaml=
let map_pair f (x,y) = (f x, f y);;
```

このプログラムでの`map_pair`の型は`('a -> 'b) -> 'a * 'a -> 'b * 'b`です．したがって

```ocaml=
map_pair (fun x -> x) (3,true)
```

のような呼び出しをしようとしても，これには型がつきません． （`map_pair`の第2引数の型でペアの1つ目の要素と2つ目の要素が同じでなければならないという制約があるため．）

しかし，もし`map_pair`の型として`(∀α.α→α)→(β*γ)→(β*γ)`のような型を許すことができれば，この関数呼び出しは型がつきます．なぜなら，この型では受け取った関数を多相的に適用でき，それにより`map_pair`の第2引数の型については`β*γ`という型を持つペアであればよいという制約しか課せられないからです．

実は OCaml ではレコード型と明示的な多相型の宣言を用いて，以下のように擬似的にこの例を書くことができます．

```ocaml=
type poly_f = { f : 'a 'b. 'a -> 'b };;
let map_pair p (x,y) = (p.f x, p.f y);;
```

ここで，`poly_f` の型においては，明示的に型が `∀αβ.α→β` という形で書かれています．これにより，`map_pair` の型は `poly_f -> 'a * 'b -> 'c * 'd` という形になり，`map_pair (fun x -> x) (3,true)` のような呼び出しは型がつくようになります．

より詳細には[ここ](https://v2.ocaml.org/manual/polymorphism.html)を参照してください．

### OCaml における型エラースライシング

> OCamlには 型エラースライシング (type-error slicing) のような方法でエラーが分かりやすく表示されないのはなぜなのでしょうか？
> ```ocaml=
> let rec f = fun x -> fun y ->
> let w = y + 1 in
> w :: y
> ```
> を入れてみてもyはint listじゃなくてintだよというエラーが出てきてどこでintと判断されたかまでは出てきませんでした。

型エラースライシングはシンプルな言語ではまあまあうまくいくのですが，OCaml のようにいろいろな言語機構が入っていると，どのようにスライシングすればよいかがあまり自明ではなく，かつ計算量も増大するから，なんじゃないかなと思っています．（が，試したことはないので，実際にはどうなのかはわかりません．実装してうまくいったらすごい．）

### 等式制約と型代入の違い

> Unificationまで実装しましたが、型代入と方程式に分けている理由がよくわかりませんでした。どちらも同じ概念のように思えてしまいます。

「制約」と「解」を別の型として定義するため，というのが直接的な理由と言えそうです．等式制約は `(ty * ty) list` 型に，型代入は`(id * ty) list` 型になります．型代入は型変数から型への写像なので，`id` がリストの各要素の第一要素になっています．一方，等式制約は型と型との間の関係なので，各要素は `ty * ty` 型となっています．もし，この2つを混ぜてしまうと，型代入を `(ty * ty) list` として定義することになってしまいますが，これでは，例えば型代入として `[(TyInt, TyInt]`のように意味をなさない値を許してしまうことになります．

### let多相

> let多相はうまく使いこなせると便利だと思った。なぜ関数型言語でしか(?)使われないのか気になった。

便利ですよね．C++ のテンプレートや Java の Generics もある意味多相型なので，他の言語でも使われ始めているといっても良さそうです．


## 構文解析について

## CやC++の構文解析

> "文脈自由文法の話のときに、字句解析や構文解析の難易度が気になりました。(以前の C++ 標準では >> のシンボルが、テンプレート引数のリストの終わりであることを示すために空白が必要だったという話を思い出して、難しいのかなと思いました)"

はい，昔のC++はたしかにそうでした．それ以外にもC++は字句解析や構文解析のフェーズと，その他の解析のフェーズとが分離できない場合があるという点で結構複雑です．

[http://yosefk.com/c++fqa/web-vs-c++.html#misfeature-2](このブログ)の記事がわかりやすいです．例えば，`x * y(z);`という expression を考えてみます．これは

```c++=
int main() {
    int x, y(int), z;
    x * y(z);
}
```

という文脈においては `x` と `y(z)` の値を掛け算する式として構文解析されるべきですが，

```c++=
int main() {
    struct x { x(int) {} } *z;
    x * y(z);
}
```

においては，`x`が型名で，`z`が`x`へのポインタとして宣言されているため，ポインタ `y` を `z` で初期化する文として構文解析される必要があります．よって，C++では構文解析を行う際に，識別子が型名か変数名かによって構文解析の仕方を変えなければならないので，型検査と構文解析のフェーズをクリアに切り分けるのが難しいです．（現実にはどうしているのかは末永もしらん．）

### 文法の曖昧性

> CFGが曖昧でないことは計算不能ですが、文法の構文を定義する際に、自分の作った文法が曖昧でないということはどうやって確認できるのでしょうか。

CFG 一般では曖昧性は決定不能なのですが，講義で紹介する LL(1) や LR(0) や LR(1) では曖昧性が決定可能です．構文解析表を作ると曖昧性があるかどうかを確認できます．今後の講義で扱いますので，そちらを参照してください．

### メジャーな構文解析アルゴリズム

> "課題の型推論の実装が進んでいき、少しずつ理解が深まっています。字句解析の講義の中で、かなり去年オートマトンの講義で知ったことが登場しているので知識が結びついているよう感覚があります。LL(1) アルゴリズムをはじめとしたいろいろアルゴリズムが出てきましたが、実際はどのアルゴリズムがメジャーなのか気になりました。"

LL も LR もよく使われている感じがします．[Wikipedia](https://en.wikipedia.org/wiki/Comparison_of_parser_generators)によくまとまっていたので，参考にしてみると良いとおもいます．

### LL(1)

> LL(1)構文解析表で表の１マスに構文規則が２つ以上入ることがないのが保証されるのはなぜですか。

> 自分が作った文法がLL(1)かどうかはどのようにして判断できるのでしょうか。

LL(1)構文解析表を作ったときに，表の1ますに規則が2つ以上入ることがない文法をLL(1)文法と言う，というのが正しいです．講義で言ったつもりになっていたのですが，伝わりづらかったかもしれません．すみません．

というわけで，LL(1)文法かどうかを判定するには，LL(1)構文解析表を作成して，規則が2つ以上入っているセルがないかどうかをチェックすることになります．

### menhir における構文解析アルゴリズム

> menhirで起こられていたconflictの意味が分かりました。menhirではどのような構文解析アルゴリズムが用いられているのでしょうか？ 

[ここ](http://gallium.inria.fr/~fpottier/menhir/)にあるように，LR(1)アルゴリズムです．

### Nullsの計算について

> Nulls等のアルゴリズムについてNullsを更新するために毎回すべての規則を見るのは計算時間がかかると思うのですが高速化することはできないのでしょうか？"

非終端記号をノードとし，$X \in \mathrm{Nulls} \implies Y \in \mathrm{Nulls}$のときに$X$から$Y$に有向辺の張られたグラフを用意して，$\mathrm{Nulls}$であることが確定しているノードから到達可能なノードの集合を適当な探索手法で求めれば，少し高速化できるかもしれません．ただ，グラフ操作のオーバーヘッドも考えると，コストに見合うのは非終端記号がまあまあ多くて，かつ不動点反復で収束するまでの回数がまあまあ多い場合かなあという気もします．（あまりちゃんと考えていません．）

### 先読み

> 先読みをどのようにするのかが気になりました

LL(1)に関しては入力がかかれたストリームの先頭の終端記号を消費することなく覗き見て，LL(1)表の情報と比較することによって行います．SLRやLR(1)の場合も入力ストリームの先頭を覗き見るのは同じなのですが，先読みをどのように使うかがやや異なります．お楽しみに．

### 空列になりうる非終端記号

> 実際に使われるような文法では εになり得る 非終端記号の割合の方が多いですか

どうでしょう．統計を取ってみないとわからないのですが，自分で文法を作るときのことを考えると，$\epsilon$になりうる非終端記号は空になりうるリストを作るときに出てきがちな気がします．それ以外のときにはあまり使わないかなあ．（個人の感想です．）

### 不動点反復の性質

> 不動点での各集合は制約を満たす最大の集合であることは証明できますか？

はい，証明できます．くわしくは[この](https://m.kulib.kyoto-u.ac.jp/webopac/EB05951457)教科書の4章や8章を読むと良いかもしれません．（実は[和訳](https://m.kulib.kyoto-u.ac.jp/webopac/BB08694195)もある．お，監訳者の名前が．．．）あとは，[Knaster-Tarskiの定理](https://en.wikipedia.org/wiki/Knaster%E2%80%93Tarski_theorem)とかをよいかも．

### LL(k)のk

> LL(k)で、実用的に使われてるkの値はどれくらいなのか気になりました"
 
[ANTLR](https://en.wikipedia.org/wiki/ANTLR)が一番よく使われているLL系のparser generatorだと思うのですが，LL(*)というのを使っているっぽいです．先読みのサイズが予めきまっていないアルゴリズムのようです．

### LR(k)

> LR(k)でも扱えない文法はありますか？

第12回講義の最後の方で少し喋った通りですが，$\bigcup_{k \in \mathbb{N}} \mathrm{LR}(k)$ を取ったとしても曖昧でない文脈自由文法の真部分集合になっています．すなわち，LR(k)でも扱えない文法があるわけですね．

### LR(0)オートマトンにおける遷移の作り方

> LR(0) の構文解析のオートマトンの受理状態に移行した後のアイテム集合を決定する操作がよくわからないのですが、以前のアイテムから受理された文字を読み出すことができるものを選んで . を進めればよいという認識であっているのでしょうか。

はい，そういうことです．もう少しきちんと書くならば，状態$q$に$X \rightarrow \alpha . X \beta$ というアイテムが入っているならば，状態$\delta(q,X)$には$X \rightarrow \alpha X . \beta$が入っているように作る，という感じですね．

### 衝突が起きたときの parser

> "Warning: 2 states have shift/reduce conflicts.
Warning: 2 shift/reduce conflicts were arbitrarily resolved.実験中、パーサに誤った変更を加えてshift-reduce conflictが起きたが、""arbitararily""に解消されたといい、実行はなされた。これは何が起きているのでしょうか。"

通常 shift-reduce conflict が先読み記号 a で起きた状態では，a を読むと shift がなされる実装になっていることが多いです．これを arbitrarily に解消された，と書いているものと思われます．[Menhirマニュアル](https://gallium.inria.fr/~fpottier/menhir/manual.pdf)の6.3節を参照してみましょう．

### LALR(1)

> LALR(1) 文法は、LR(1) に対して先読み文字が異なるものをマージしていますが、表現力が犠牲になる割にはあまり状態数が減らないような気がします。構文解析表を作る段階で LR(1) よりも高速なところがあったりするのでしょうか。"

講義の例だとあまり減らない感じがしますが，大きい文法になると結構マージできるところがあるのだと思います．（僕もあまり詳しくない．）授業で説明した通り，LR(1)解析表を経由せずに LALR(1)解析表を作成するならば多分高速にできるのだと思います．

## その他

### プログラミング課題と大規模言語モデル

> GitHub Copilotを使っているのですが（[宣伝]学生は無料で使えるのでVSCodeユーザの皆さんはぜひ使ってみた方が良いと思います！）、syntax.mlやeval.mlに関数を処理するコードを追加する部分で完璧に補完だけで正しいコードが出てきてしまい思わず笑ってしまいました（parser.mlyもほぼ全部分に成功）。こんな時代にプログラマ・ソフトウェアエンジニアとして生き残っていくためにはどうしたら良いと思いますか。形式検証の専門家という立場からのお答えをお聞きしたいです。

（この辺のプログラムは頻出なので，一瞬で出てくるでしょうなあ．できれば課題は初回は自分で考えてみてね．Copilot 使うときは出てきたコードは完璧に理解してね．）

コードスニペットを Web から探して参考にすること自体はこれまでもみんなやっていたことなのですが，Copilot や LLM によってそれがかなり簡単にできるようになったという感じがします．課題を出す大学教員としては頭が痛いところですが，コード書く人間としてはいい時代だなあと思います．ただ，出力されるコードの正しさは担保されていない（というより結構間違ったコードを書いてくる）という感じがするので，テストや形式検証によって正しいプログラムを作るスキルは今まで以上に大事になるのかなあと思っています．あとは「プログラムを書ける」というスキルがコモディティ化していくことで，ソフトウェアをどう問題解決に使うのかという方向のスキルが必要になるのかもしれません．そのためには，より深く広い技術への理解やとともに，ビジネスの知識やドメイン知識を嫌がらずに学ぶことが大事になってくるんじゃないでしょうか．

ところで，GPT-4は以下のようにお考えのようです．

> GitHub Copilotが役立っているようで良かったですね。AI技術の進化はプログラミングの世界にも大きな影響を与えており、プログラマーやソフトウェアエンジニアにも新たなスキルが求められています。
> 形式検証の専門家として、プログラマーやソフトウェアエンジニアが時代の変化に適応し、生き残っていくためのアドバイスをいくつかご紹介します。
> 
> - 深い理解と知識の習得: AIがある程度のコーディングを補助できるようになりましたが、基本的なプログラミング知識や理解力は必要不可欠です。技術の基礎をしっかり学び、専門的な知識を習得しましょう。
> - 問題解決能力の向上: 複雑な問題に対処し、効率的な解決策を見つけ出す能力は、AIにはなかなか真似できないスキルです。問題解決能力を磨くことで、価値あるエンジニアとなります。
> - コミュニケーション能力: チームでの協力や、他の専門家との連携が重要になるため、コミュニケーション能力を鍛えることが大切です。
> - 創造性と革新性: AIはあくまで人間が作ったツールです。新しいアイデアや革新的なソリューションを生み出す能力は、エンジニアにとって重要な価値を持ちます。
> - 学ぶ意欲: 技術は常に進化しています。新しい知識や技術を学び続けることで、時代の変化に柔軟に対応できます。
> 
> 形式検証の専門家として、これらのスキルや能力を磨くことが、プログラマーやソフトウェアエンジニアがAI時代に生き残るための鍵だと考えます。これからも努力を続け、自分自身を成長させていくことが大切です。

わしの答えとどちらが正しいであろうか．

### 「言語機構」の英訳

> 言語機構の英語訳が見つかりませんが、「language construct」でいいのでしょうか。（言語機構というのはどういう意味ですか。具体的な例はありますか。）

「プログラミング言語の機能」くらいの意味で使っていました．たしかに DeepL とかだと "language construct" が推薦されるのですが，これはどちらかというとプログラミング言語の構文要素を言っているイメージがあります． "Functionality of a language"とか "feature of a language" とかのほうがピッタリくるかも．（自信なし）

### `test/dune` について

> test/duneの仕組みが気になります。（testが失敗したときにどこが悪いのか分からなくて困っています）

`dune` は OCaml のビルドシステム dune の設定ファイルです． `test/dune` は，`test`ディレクトリに含まれているテストが列挙されています．テストを実行したときに出るエラーに各テストの番号がついていると思うのですが，この番号は各対応している `test/dune` 中のファイル（例えば問題3.5.1ならex3_5_1.ml）に定義されている各テストの番号になっています．（最初が0番，次が1番...）テストが fail したときは，テストの番号からどの入力に対してどのような結果が期待されているかをテストの定義から読み解き，何が誤っているかを考えると良いと思います．

### モデル検査ツール

> 授業とは直接関係ないですが、おすすめのモデル検査ツールあれば教えてください。"

一番お手軽に使えるのは[infer](https://fbinfer.com/)ですかね．従来のオートマトンベースのモデル検査器ではなく，どちらかというとプログラム論理に基づく検証器なのですが，使うのが簡単です．とりあえず[このあたり](https://fbinfer.com/docs/getting-started/)を使ってみるとよいです．
