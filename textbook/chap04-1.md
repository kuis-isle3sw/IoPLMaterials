{% include head.html %}

# 静的プログラム検証へのイントロダクション

## ある研究者（あるいは卒論生）の悲劇

これまでに実装したインタプリタは，与えられたプログラムを，セマンティクスにしたがって評価することにより実行結果を得ていた．例えば，実装したインタプリタを使って式`3+5`を評価すると`8`が評価結果として返ってくる．式`let x = 2 in x + 3`を評価すると`5`が評価結果として返ってくる．

一方で，このインタプリタは評価するプログラムによっては実行時に型エラーを起こして落ちてしまうことがある．例えば，`3 4` は関数ではない値 `3` を適用しようとしていて実行時型エラーを起こすし（実際に評価してみよう），`let f x = x + 1 in f true` も実行時型エラーを起こす（実際に試してみよう）．

### 1億回後に死ぬプログラム

実行時型エラーは結構困りものである．以下の例を見てみよう．
- あなた（23:00）「明日の12:00論文締め切りなのに，追加の実験がどうしても必要になった．．．よし，プログラムを書こう．」
- あなた（3:00）「[ヨシ！](https://ja.wikipedia.org/wiki/%E7%8F%BE%E5%A0%B4%E7%8C%AB)できた！」
- ```ocaml
let rec f x n =
  if n <= 0 then 3 4 (* (A) *)
  else
    let x = (* めっちゃ重い計算 *)
    f x (n + -1)
in
f 0 100000000
```
- あなた「このプログラムは，めっちゃ重い計算を1億回繰り返すのだ．明日の朝には実験結果が出るはずだな．[プログラムを走らせたまま寝て，明日の朝結果を論文に反映させよう．](https://ja.wikipedia.org/wiki/%E3%83%95%E3%83%A9%E3%82%B0_(%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AA%E3%83%BC))」
- あなた（睡眠中）
- あなた（11:00）「いかんいかん，寝過ごすところだった．実験結果は出ているかな．」
- `3 4 を評価しようとしましたが，3 は関数ではありません．落ちます．`
- あなた「」

### 解決策

このような悲劇を防ぐ方法はあるだろうか．まず繰り返し回数を減らしてテストをせよ，というアドバイスはもっともだが，締め切り1日前の午前3:00には冷静にテストをできないかもしれない．そんな締切ギリギリになって実験をするのが悪いというアドバイスももっともだが，そんなシチュエーションになったことが無い者のみが石を投げなさい．

もし，このプログラムを _実行することなく_ `(* (A) *)`の場所に型エラーの可能性があることが分かるとしたらどうだろうか．プログラムを走らせようとすると，処理系が自動的に `(* (A) *)のところに型エラーがあるから走らせられませんねえ`と知らせてくれる．これを修正して走らせれば（プログラムの修正に1分くらいかかって，走らせ始めるのが 3:01 くらいになるかもしれないが）次の日に無事論文に新しい実験結果が載せられるだろう．

しかし，プログラムを実行させずにプログラムの実行結果についての情報を得ることが本当に可能だろうか．実は，すでに皆さんはその技術を使っている．先程のプログラムを，めっちゃ重い計算ではないがもう少し軽い計算を繰り返すプログラムにしてみて，繰り返しのたびにメッセージを出力するようにして，`ocaml` に食べさせてみよう．

```ocaml
let rec f x n =
  if n <= 0 then 3 4 (* (A) *)
  else
    let x = x mod 2 in
    Format.printf "Hoge.@\n";
    f x (n + -1)
in
f 0 100000000
```
```console
ocaml
OCaml version 4.06.1
...

# let rec f x n =
    if n <= 0 then 3 4 (* (A) *)
    else
      let x = x mod 2 in
      Format.printf "Hoge.@\n";
      f x (n + -1)
  in
  f 0 100000000;;
Error: This expression has type int
       This is not a function; it cannot be applied.
```

ここまでの演習をやった人であれば，このエラーメッセージを何度も見たことだろう．だが，ここで注目すべきはエラーメッセージではなく，`Hoge.`という文字列が出力されていないことである．もしプログラムが実行された上で型エラーが検出されたのならば，この文字列が1億回出力されているはずである．つまり，`ocaml`は， _プログラムを実行することなく，型エラーが存在する可能性を指摘している．_

### 静的プログラム検証

_静的プログラム検証 (static program verification)_ は，プログラムを実行することなく，その内容を解析し，何らかの性質（ここでは実行時に型エラーが起こり得ないこと）が満たされているかどうかを検査する手法である．静的プログラム検証<sup>[静的・動的についての注](#static)</sup>は，検証に用いる手法の正しさが数学的に厳密に証明されているときに _形式検証 (formal verification)_ と呼ばれる．<sup>[名称についての注](#jargon)</sup>

<a name="static">静的・動的</a>:「静的検証」の「静的」は "static" の訳で，プログラムの実行時の情報（例えば，プログラムの実行途中での環境の内容等）を用いず，実行前に得られる情報のみを用いるという意味である．対比される言葉に「動的検査」がある．これはプログラムの実行途中に行う検査で，例えば実行時型検査（実行時に関数適用を行う前に，関数として扱われるべき値が実際に関数であるかの検査等）やテスト，プロファイリングなどはこれに類する．なお，「静的検証」と「動的検査」は，どちらが優れているというものではない．というのは，「静的検査」によって何らかの性質を保証する問題は，大体の性質では決定不能（任意のプログラムを扱うことのできる，与えられた性質が成り立つかどうかについて，必ず正しい結果を出力して停止する検証アルゴリズムが存在しない）になってしまうからである．したがって，静的検査では，扱えるプログラムの種類を限定したり，検証手続きの停止性を諦めたり，出力された結果の正しさを一部諦めたり（具体的には，「バグがあるかも」と判断されても，実際にはバグがない可能性を許す）する必要がある．したがって，静的検証を用いる場合にも，動的検査と組み合わせて使う必要がある．

<a name="jargon">名称について</a>: 「形式」は，多分 "formal" の訳で，「これでただしいんじゃん？」という感じで適当に（"informal" に）検証をするのではなく，数学的に検証手法の正しさを証明しましょう，という気持ちがこもっている．似た言葉として _形式手法 (formal method)_ という言葉を聞くことがあるかもしれない．これは，上記の意味でのプログラムの正しさの検証のみならず，ソフトウェア設計やテストケース設計などのソフトウェア開発一般に数学を使う手法で，形式検証はその意味で形式手法の一分野である．なお，同様の意味で _静的解析 (static analysis)_ と言うと，静的検証の一手法である _抽象解釈 (abstract interpretation)_ を使ったプログラム検証を指すことがある．（用語が混乱していて分かりにくい．僕も困っている．）

<!-- プログラムを実行すれば実行結果が得られるのに，なぜわざわざ静的解析をや
ろうとするのだろうか．静的解析の用途としては，例えば以下のものがある．
\begin{itemize}
\item 静的解析によって，プログラムの実行に一切影響を与えないプログラム
  中の部分を発見したり，常に一定の値を取る変数を発見するなどして，プロ
  グラムの実行効率を上げることができる．これらは言語処理系，特にコンパ
  イラの文脈では\intro{最適化}{optimization}として知られる処理である．
\item プログラム中には「絶対に成り立っているはずというプログラマの意図」
  を\intro{アサーション}{assertion}として記述することがある．例えば，
  以下のC言語の関数@sum@は2つの整数引数@x@と@y@をとり，@x+y@を返す関数
  であるというプログラマの意図が@assert(ret == x + y);@という文で表現
  されている．\footnote{@assert(e)@は実行時には@e@を評価し，その結果が偽（C言語では@0@）であ
  ればエラーを報告してプログラムを終了する関数やマクロとして実装されていること
  が多い．}
  #{&}
  /* Returns x+y */
  unsigned int sum(unsigned int x, unsigned int y) {
    unsigned int i = 0;
    unsigned int ret = x;
    while (i < y) {
      ++i; ++ret;
    }
    assert(ret == x + y);
    return ret;
  }
  #{@}
  アサーションはプログラマが「絶対に成り立つ」と表明した条件なので，こ
  れが実際に成り立っていることを保証するのは，プログラムの信頼性を向上
  させる上で重要である．これを保証する手段として静的解析が使われること
  がある．つまり，@assert@文が実行されるときには引数が@0@ではないこと
  を，プログラムを解析することによっていわば「証明」することで，アサー
  ションが必ず成り立つことを保証するわけである．

  ここでは例として@assert@が成り立っていることを保証するための解析につ
  いて取り上げたがより一般に「プログラムが意図（＝仕様）通りに動作する
    ことを証明するための静的解析」を\intro{形式検証}{formal
    verification}と呼ぶ．\footnote{ちなみに，上
    記のプログラムでは，@while@ループで条件がテストされる際に必ず
    @ret - i == x && i <= y@が成り立っていることを発見できれば，
    アサーションが必ず成り立つことが証明できる．（ループを抜けたときには，
      @while@文の条件節が偽になるはずなので，@i >= y@が成り立っているはずである．
      すると，上記の条件と合わせて@ret - i == x && i == y@が成り立っていることになり，
      ここから@ret == x + y@が導ける．）このようなループ文の先頭に
    到達したときに必ず成り立っている条件を\intro{ループ不変条件}{loop invariant}と
    呼ぶ．良いループ不変条件を発見するのは，形式検証においてとても重要な
    テクニックである．また，自分でプログラムを書く際にも，ループ不変条件を
    意識して書くことで，バグを減らせることが多い．}
\end{itemize} -->


<!-- では，プログラムの実行結果についての情報を得る方法は評価だけなのだろうか．\emph{プログラム実行することなく}プログラムの実行結果についてなんらかの情報を予測することは可能だろうか．こ章のテーマは，プログラムを実行せずに解析して，その実行についての情報を得る方法である\intro静的解析}{static analysis}である．\footnote{ここでいう「静的」とは「プログラムを実行る前に」という意味である．反対にプログラムを実行させて行う解析を\intro{動的解析}dynamic analysis}と呼ぶ．例えば，プログラムを実行して実行時間の大部分を占める（すなわち効率化をすることで効果が上がりやすい）関数を探す方法（\intro{プロファイリング}{profiling}）や，プログラムを様々な入力で実行してバグを見つける方法（\intro{ソフトウェアテスト}{software test}）はそのような動的解析の一種である．} -->


<!-- 形式検証は，テストを補完する方法として最近結構使われ始めている．
\footnote{例えばFacebookはinferという形式検証ツールをソースコード管理
  ツールと統合して動作させており，プログラマがコミットした内容を自動で
  検証し，誤りの可能性を自動的に指摘するということをやっているとのこと
  である\cite{}．}本章は，簡単な形式検証手法を実装してみることにより，
静的解析に馴染んでもらうことを目的としている．静的解析のうち，上で取り
上げた最適化については，後日講義で取り上げる予定である． -->

本章では，これまでに実装した MiniML 処理系に，静的検証の一種である _静的型推論 (static type inference)_ を実装する．OCaml でプログラムを書くと自動で型を推論してくれて，型エラーがあれば知らせてくれるアレである．型推論はプログラム中の式が（評価が停止するならば）どのような値を返すかを _プログラムを実行することなく_ 解析するので静的検証の一種である．また，プログラムが _実行時に型エラーを起こさない_ ことを証明するための手法であるため，形式検証と言える．

<!-- なお，上で説明したちょっと格好いい形式検証に比べて，だいぶ保証する性質がしょぼく見えるかも知れないが，人間はそういうしょぼいエラーを含むプログラムを頻繁に書く（実行時型エラーに遭遇してしょんぼりした経験ない？），軽い解析なのに結構役に立つ，モジュールに基づく情報の隠蔽  と相性が良い，関数型言語ととても相性がよい，型推論をベースにしてさら  に格好いい形式検証を作ることができる等の利点がある．} -->

本章では，これまでに実装した言語のための型推論を解説する．まず MiniML2 のための型推論からはじめて，徐々に言語を拡張しつつ，拡張された言語機能のための型推論を行う方法を解説する．
